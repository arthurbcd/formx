// ignore_for_file: cast_nullable_to_non_nullable, overridden_fields

// Generated by Dart Safe Data Class Generator. * Change this header on extension settings *
// ignore_for_file: type=lint
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';

import '../../formx.dart';

/// Extends [FormFieldState] with a programatic way to set [errorText].
extension FormFieldStateExtension<T> on FormFieldState<T> {
  /// The [Key] `value` of this [FormFieldState].
  String? get key => widget.key?.value;

  /// The [FieldAdapter] of this [FormFieldState].
  FieldKey<T>? get fieldKey {
    return widget.key?.tryCast<FieldKey<T>>();
  }

  /// Sets the [errorText] programatically.
  ///
  /// You need to set a [Validator] to use this method.
  void setErrorText(String? errorText) {
    attachToValidator(errorText: errorText);
    validate();
  }

  /// Returns the [FormFieldState.value] as a [String].
  @Deprecated('Use `.text` instead.')
  String get string => value?.toString() ?? '';

  /// Returns the [FormFieldState.value] as a [String].
  String get text {
    if (value is DateTime) {
      return Formx.options.dateAdapter(value as DateTime)?.toString() ?? '';
    }
    return value?.toString() ?? '';
  }

  /// Returns the [FormFieldState.value] as a [DateTime].
  DateTime? get date => value?.tryCast<DateTime>() ?? DateTime.tryParse(text);

  /// Returns the [FormFieldState.value] as a [num].
  num? get number => value?.tryCast<num>() ?? num.tryParse(text);
}

/// Attaches a [FormFieldState] to a [Validator].
extension FormFieldStateAttacher on FormFieldState {
  /// Attaches this [FormFieldState] to the [Validator].
  @protected
  void attachToValidator({String? errorText}) {
    final FormFieldData data;
    try {
      data = (
        state: this,
        errorText: errorText,
      );
      widget.validator?.call(data);
    } catch (_) {
      assert(
        errorText == null,
        'No `Validator` was set for this `$this`.\n'
        'You must set `Validator` class in order to call `setErrorText`.\n'
        'Ex:\n'
        '```dart\n'
        'TextFormField(\n'
        "   key: const Key('email'),\n "
        '  validator: Validator(), // <-- set your `Validator` here\n'
        ')\n'
        '```\n'
        'Then call:\n'
        '```dart\n'
        "emailState?.setErrorText('errorText');\n"
        '```\n',
      );
    }
  }
}

/// Signature for binding a [FormFieldState] to a [FormFieldValidator].
typedef FormFieldData = ({FormFieldState state, String? errorText});

/// Extension for [Key] value.
extension FormFieldKeyExtension on Key {
  /// Attempts to get the [value] of this [Key] if it is an [String].
  String? get value {
    if (this case ValueKey(:String value)) return value;
    if (this case ObjectKey(:String value)) return value;
    if (this case GlobalObjectKey(:String value)) return value;
    return null;
  }

  /// Returns a [FieldKey] with this [Key] value.
  FieldKey<T> field<T>({FieldAdapter<T>? adapter, bool? unmask}) {
    final value = ArgumentError.checkNotNull(this.value, 'value');

    return FieldKey(value, adapter: adapter, unmask: unmask);
  }

  /// Creates a `FieldKey<DateTime>` with this [Key] value.
  FieldKey<DateTime> date([FieldAdapter<DateTime>? adapter]) {
    return field(adapter: adapter);
  }

  /// Creates a `FieldKey<String>` with this [Key] value.
  FieldKey<String> text([FieldAdapter<String>? adapter]) {
    return field(adapter: adapter);
  }

  /// Whether to unmask the value. Overrides [FormxOptions.unmask].
  FieldKey<T> unmasked<T>() => field(unmask: true);

  /// Whether to mask the value. Overrides [FormxOptions.unmask].
  FieldKey<T> masked<T>() => field(unmask: false);
}

/// Extension for `FieldKey<T>`.
extension FieldKeyExtension<T> on FieldKey<T> {
  /// Whether to unmask the value. Overrides [FormxOptions.unmask].
  FieldKey<T> unmasked() => copyWith(unmask: true);

  /// Whether to mask the value. Overrides [FormxOptions.unmask].
  FieldKey<T> masked() => copyWith(unmask: false);
}

/// Extension for `FieldKey<String>`.
extension NumberFieldKeyExtension on FieldKey<String> {
  /// Adapt [String] `value` to [int] in `FormState.values`.
  FieldKey<String> toInt() {
    return copyWith(adapter: (value) => int.tryParse(value ?? ''));
  }

  /// Adapt [String] `value` to [double] in `FormState.values`.
  FieldKey<String> toDouble() {
    return copyWith(adapter: (value) => double.tryParse(value ?? ''));
  }
}

/// Extension for `FieldKey<DateTime>`.
extension DateFieldKeyExtension on FieldKey<DateTime> {
  /// Adapt [DateTime] `value` to a [String] in `FormState.values`.
  FieldKey<DateTime> toLocalIso8601String() {
    return copyWith(adapter: (value) => value?.toLocal().toIso8601String());
  }

  /// Adapt [DateTime] `value` to a [String] in `FormState.values`.
  FieldKey<DateTime> toUtcIso8601String() {
    return copyWith(adapter: (value) => value?.toUtc().toIso8601String());
  }

  /// Adapt [DateTime] `value` to a [int] in `FormState.values`.
  FieldKey<DateTime> toMillisecondsSinceEpoch() {
    return copyWith(adapter: (value) => value?.millisecondsSinceEpoch);
  }
}

/// A function to adapt a [Object] value to any value.
typedef FieldAdapter<T extends Object?> = dynamic Function(T? value);

/// A [Key] for a [FormField].
@immutable
class FieldKey<T> extends GlobalObjectKey<FormFieldState<T>> {
  /// Creates a [FieldKey] with a [value].
  const FieldKey(this.value, {this.adapter, this.unmask}) : super(value);

  @override
  final String value;

  /// The adapter function to convert the [T] to any value.
  final FieldAdapter<T>? adapter;

  /// Adapts the [value] if same type. Otherwise, returns the same [value].
  dynamic maybeAdapt(dynamic value) {
    if (value is! T) return value;

    return adapter?.call(value);
  }

  /// Whether to unmask the value. Overrides [FormxOptions.unmask].
  final bool? unmask;

  /// Creates a new [FieldKey] with values from this [FieldKey].
  FieldKey<T> copyWith({
    String? value,
    FieldAdapter<T>? adapter,
    bool? unmask,
  }) {
    return FieldKey<T>(
      value ?? this.value,
      adapter: adapter ?? this.adapter,
      unmask: unmask ?? this.unmask,
    );
  }
}
